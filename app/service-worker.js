// This file is intentionally without code.
// It's present so that service worker registration will work when serving from the 'app' directory.
// The version of service-worker.js that's present in the 'dist' directory is automatically
// generated by the 'generate-service-worker' gulp task, and contains code to precache resources.
const _self = this;

var CACHE_NAME = 'lzq-cache-v2';
var urlsToCache = [
  '/styles/main.css',
];

self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(function(cache) {
        console.log('Opened cache');
        return cache.addAll(urlsToCache);
      })
  );
});

_self.addEventListener('activate', function () {
  console.log('Activated');
});

_self.addEventListener('message', function(event) {
  console.log('received message success')
  console.log(event.data);
});

_self.clients.matchAll().then(function(clients) {
  clients.forEach(function(client) {
    console.log('1-----client')
    client.postMessage('Service worker attached.');
  })
});

// const handleFetchRequest = function(request) {
//   return fetch(request);
// };

// const handleFetchRequest = function(request) {
//   return caches.match(request)
//     .then(function(response) {
//       return response || fetch(request)
//         .then(function(response) {
//           const clonedResponse = response.clone();
//
//           caches.open(CACHE_NAME)
//             .then(function(cache) {
//               cache.put(request, clonedResponse);
//             });
//
//           return response;
//         });
//     });
// };

// const HOST_NAME = location.host;
// const VERSION_NAME = 'CACHE-v1';
// const CACHE_NAME = HOST_NAME + '-' + VERSION_NAME;
// const CACHE_HOST = [HOST_NAME, 'cdn.bootcss.com'];
//
// const isNeedCache = function(url) {
//   return CACHE_HOST.some(function(host) {
//     return url.search(host) !== -1;
//   });
// };
//
// const isCORSRequest = function(url, host) {
//   return url.search(host) === -1;
// };
//
// const isValidResponse = function(response) {
//   return response && response.status >= 200 && response.status < 400;
// };
//
// const handleFetchRequest = function(req) {
//   if (isNeedCache(req.url)) {
//     const request = isCORSRequest(req.url, HOST_NAME) ? new Request(req.url, {mode: 'cors'}) : req;
//     return caches.match(request)
//       .then(function(response) {
//         // Cache hit - return response directly
//         if (response) {
//           // Update Cache for next time enter
//           fetch(request)
//             .then(function(response) {
//
//               // Check a valid response
//               if(isValidResponse(response)) {
//                 caches
//                   .open(CACHE_NAME)
//                   .then(function (cache) {
//                     cache.put(request, response);
//                   });
//               } else {
//                 sentMessage('Update cache ' + request.url + ' fail: ' + response.message);
//               }
//             })
//             .catch(function(err) {
//               sentMessage('Update cache ' + request.url + ' fail: ' + err.message);
//             });
//           return response;
//         }
//         // Return fetch response
//         return fetch(request)
//           .then(function(response) {
//             // Check if we received an unvalid response
//             if(!isValidResponse(response)) {
//               return response;
//             }
//
//             const clonedResponse = response.clone();
//
//             caches
//               .open(CACHE_NAME)
//               .then(function(cache) {
//                 cache.put(request, clonedResponse);
//               });
//
//             return response;
//           });
//       });
//   } else {
//     return fetch(req);
//   }
// };
//
// const onFetch = function(event) {
//   event.respondWith(handleFetchRequest(event.request));
// };
//
// _self.addEventListener('fetch', onFetch);


//资源白名单，一般通过构建工具(webpack)生成
var allAssets = [
  '/styles/main.css'
];

//白名单匹配策略
function matchAssets(requestUrl) {
  var urlObj = new URL(requestUrl);
  var noProtocolUrl = urlObj.pathname;
  if (allAssets.indexOf(noProtocolUrl) !== -1) {
    return true;
  }
  return false;
}

self.addEventListener('fetch', function(event) {

  console.log('event.request.url',event.request.url)
  console.log('event.request.method',event.request.method)
  var requestUrl = event.request.url;
  var isGET = event.request.method === 'GET';
  var assetMatches = matchAssets(requestUrl);
  if (!assetMatches || !isGET) {
    return;
  }

  event.respondWith(
    caches.match(event.request)
      .then(function(response) {
        if (response) {
          return response;
        }

        var fetchRequest = event.request.clone();

        return fetch(fetchRequest).then(
          function(response) {
            // Check if we received a valid response
            if(!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }

            var responseToCache = response.clone();

            caches.open(CACHE_NAME)
              .then(function(cache) {
                cache.put(event.request, responseToCache);
              });

            return response;
          }
        );
      })
  );
});

self.addEventListener('activate', function(event) {

  var cacheWhitelist = ['lzq-cache-v2'];

  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// const onActive = function(event) {
//   event.waitUntil(
//     caches
//       .keys()
//       .then(function(cacheNames) {
//         return Promise.all(
//           cacheNames.map(function(cacheName) {
//             // Remove expired cache response
//             if (CACHE_NAME.indexOf(cacheName) === -1) {
//               return caches.delete(cacheName);
//             }
//           })
//         );
//       })
//   );
// };
//
// _self.addEventListener('activate', onActive);

